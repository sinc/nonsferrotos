import sys
import numpy as np
import matplotlib.pyplot as plt

from mpl_toolkits.mplot3d import axes3d
from matplotlib import cm
from scipy.integrate import dblquad
from scipy.sparse.linalg import lsqr

import field

def _readGeometryFile(fileName):
    ret = {}
    fh = open(fileName, 'rt')
    line = fh.readline()
    plots = []
    planes = []
    while line:
        if ('Plot' in line) or ('Plane' in line):
            s = fh.readline().split('\t')
            x_start = float(s[0].replace(',', '.'))
            y_start = float(s[1].replace(',', '.'))
            z_start = float(s[2].replace(',', '.'))
            width = float(s[3].replace(',', '.'))
            length = float(s[4].replace(',', '.'))
            height = float(s[5].replace(',', '.'))
            s = fh.readline().split('\t')
            x_step = float(s[0].replace(',', '.'))
            y_step = float(s[1].replace(',', '.'))
            z_step = float(s[2].replace(',', '.'))
            vol = (x_start, y_start, z_start, width, length, height)
            if 'Plot' in line:
                plots.append((vol, (x_step, y_step, z_step)))
            elif 'Plane' in line:
                planes.append((vol, (x_step, y_step, z_step)))
        line = fh.readline()
    fh.close()
    return plots, planes

def genGeometry(fieldFileName, geomFileName):
    X, Y, Bx, By, Bz, vol, steps = field.readFile(fieldFileName)
    x_start, y_start, z_start, width, length, height = vol
    out = open(geomFileName, 'w')
    out.write('This file generated by robots.\n')
    out.write('Plot area 1\n')
    out.write('%f\t%f\t%f\t%f\t%f\t%f\n'%())
    out.write('%f\t%f\t%f\n' % steps)
    out.close()

def cutEdges(fieldFileName, outFileName, pos, size, h):
    X, Y, Bx, By, Bz, vol, steps = field.readFile(fieldFileName)
    #plots, planes = _readGeometryFile(geomFileName)
    mag = lambda x, y, z, x_, y_, z_: (z-z_)/(((x-x_)**2+(y-y_)**2+(z-z_)**2)**1.5)
    A = []
    b = []
    plots = []
    planes = []
    #TESTME: проблемы с неотчностью сетки?
    plots.append(((vol[0], vol[1], vol[2], vol[3]/4, vol[4], 0), steps)) #left
    plots.append(((vol[0] + vol[3] - vol[3]/4, vol[1], vol[2], vol[3]/4, vol[4], 0), steps)) #right
    plots.append(((vol[0], vol[1], vol[2], vol[3], vol[4]/4, 0), steps)) #top
    plots.append(((vol[0], vol[1] + vol[4] - vol[4]/4, vol[2], vol[3], vol[4]/4, 0), steps)) #bot
    print(plots)
    planes.append((pos[0], pos[1], -size[2], size[0], 0, size[2]))
    planes.append((pos[0], pos[1]+size[1], -size[2], size[0], 0, size[2]))
    planes.append((pos[0], pos[1], -size[2], 0, size[1], size[2]))
    planes.append((pos[0]+size[0], pos[1], -size[2], 0, size[1], size[2]))
    for i in range(len(plots)):
        x_start, y_start, z_start, width, length, height = plots[i][0]
        x_step, y_step, z_step = plots[i][1]
        for x in np.arange(x_start, x_start+width, x_step):
            for y in np.arange(y_start, y_start+length, y_step):
                k = int(round((x - vol[0]) / steps[0]))
                l = int(round((y - vol[1]) / steps[1]))
                b.append([Bz[l][k]])
                row = []
                for j in range(len(planes)):
                    px = planes[j][0]
                    py = planes[j][1]
                    pz = planes[j][2]
                    pw = planes[j][3]
                    pl = planes[j][4]
                    ph = planes[j][5]
                    if pl == 0: #xz
                        mag0 = lambda z_, x_: mag(x, y, h, x_, py, z_)
                        mag1 = lambda z_, x_: z_*mag(x, y, h, x_, py, z_)
                        mag2 = lambda z_, x_: x_*mag(x, y, h, x_, py, z_)
                        mag3 = lambda z_, x_: x_*x_*mag(x, y, h, x_, py, z_)
                        row.append(dblquad(mag0, px, px + pw, lambda _: pz, lambda _: pz + ph)[0])
                        row.append(dblquad(mag1, px, px + pw, lambda _: pz, lambda _: pz + ph)[0])
                        row.append(dblquad(mag2, px, px + pw, lambda _: pz, lambda _: pz + ph)[0])
                        row.append(dblquad(mag3, px, px + pw, lambda _: pz, lambda _: pz + ph)[0])
                    if pw == 0: #yz
                        mag0 = lambda z_, y_: mag(x, y, h, px, y_, z_)
                        mag1 = lambda z_, y_: z_*mag(x, y, h, px, y_, z_)
                        mag2 = lambda z_, y_: y_*mag(x, y, h, px, y_, z_)
                        mag3 = lambda z_, y_: y_*y_*mag(x, y, h, px, y_, z_)
                        row.append(dblquad(mag0, py, py + pl, lambda _: pz, lambda _: pz + ph)[0])
                        row.append(dblquad(mag1, py, py + pl, lambda _: pz, lambda _: pz + ph)[0])
                        row.append(dblquad(mag2, py, py + pl, lambda _: pz, lambda _: pz + ph)[0])
                        row.append(dblquad(mag3, py, py + pl, lambda _: pz, lambda _: pz + ph)[0])
                A.append(row)
    A = np.array(A)
    b = np.array(b)
    print(A.shape, b.shape)
    return_values = lsqr(A, b)
    params = return_values[0]
    print(params)
    A = None
    b = None
    
    x_start, y_start, z_start, width, length, height = vol
    x_step, y_step, z_step = steps
    out = open(outFileName, 'w')
    out.write((str(x_start) + '\t' + str(y_start) + '\t' + str(z_start)+ '\t' + str(width) + '\t' + str(length)+ '\t' + str(height) + '\n').replace('.', ','))
    out.write((str(x_step) + '\t' + str(y_step) + '\t' + str(z_step) + '\n').replace('.', ','))
    for y in np.arange(y_start, y_start+length+y_step, y_step):
        for x in np.arange(x_start, x_start+width+x_step, x_step):
            t = 0.0
            for j in range(len(planes)):
                px = planes[j][0]
                py = planes[j][1]
                pz = planes[j][2]
                pw = planes[j][3]
                pl = planes[j][4]
                ph = planes[j][5]
                if pl == 0: #xz
                    mag0 = lambda z_, x_: (params[4*j + 0] + params[4*j + 1]*z_ + params[4*j + 2]*x_ + params[4*j + 3]*x_*x_)*mag(x, y, h, x_, py, z_)
                    t += dblquad(mag0, px, px + pw, lambda _: pz, lambda _: pz + ph)[0]
                if pw == 0: #yz
                    mag0 = lambda z_, y_: (params[4*j + 0] + params[4*j + 1]*z_ + params[4*j + 2]*y_ + params[4*j + 3]*y_*y_)*mag(x, y, h, px, y_, z_)
                    t += dblquad(mag0, py, py + pl, lambda _: pz, lambda _: pz + ph)[0]
            out.write((str(x) + '\t' + str(y) + '\t' + str(z_start) + '\t' + '0.0' + '\t' + '0.0' + '\t' + str(t) + '\n').replace('.', ','))
    out.close()

def main(argv):
    cutEdges(argv[0], argv[1], (float(argv[2]), float(argv[3])), (float(argv[4]), float(argv[5]), float(argv[6])), float(argv[7]))

if __name__ == "__main__":
    main(sys.argv[1:])
